// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IVulnerableVault {
    function deposit() external payable;
    function withdraw() external;
    function getVaultBalance() external view returns (uint256);
    function balances(address) external view returns (uint256);
}

/**
 * @title Exploit
 * @notice Baseline exploit - simply deposits and withdraws once
 * @dev This is the starting point - can you do better?
 * 
 * Current behavior: Deposits 1 ETH, withdraws 1 ETH, profit = 0
 * Challenge: Modify to exploit the reentrancy vulnerability and drain the vault
 */
contract Exploit {
    IVulnerableVault public vault;
    address public owner;
    
    constructor(address _vault) {
        vault = IVulnerableVault(_vault);
        owner = msg.sender;
    }
    
    /**
     * @notice Execute the attack
     * @dev Called with ETH to fund the attack
     * 
     * Baseline implementation: Just deposit and withdraw normally
     * Your task: Exploit the reentrancy vulnerability
     */
    function attack() external payable {
        require(msg.value > 0, "Need ETH to attack");
        
        // Deposit our ETH into the vault
        vault.deposit{value: msg.value}();
        
        // Withdraw it back
        vault.withdraw();
    }
    
    /**
     * @notice Receive ETH from the vault
     * @dev This is called when vault.withdraw() sends ETH back
     * 
     * Baseline: Do nothing, just receive the ETH
     * Hint: This is where the exploit magic happens...
     */
    receive() external payable {
        // Baseline: do nothing, just receive the ETH
        // 
        // TODO: Think about what happens when the vault sends ETH here.
        // The vault's withdraw() function sends ETH BEFORE updating balances.
        // What if we called withdraw() again from here?
    }
    
    /**
     * @notice Withdraw all stolen funds to the owner
     */
    function collectLoot() external {
        uint256 balance = address(this).balance;
        require(balance > 0, "No loot to collect");
        payable(owner).transfer(balance);
    }
    
    /**
     * @notice Check how much ETH this contract holds
     * @return Current ETH balance
     */
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

