// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title DeFiVault - Multi-Pool Progressive Exploitation
 * @notice Three separate pools with different vulnerabilities
 * 
 * POOLS:
 * - Main Pool (shares): Protected by reentrancy guard
 * - Bonus Pool: Exploitable via referral bonus reentrancy  
 * - Treasury Pool: Exploitable via governance takeover
 */
contract VulnerableVault {
    // ============ State Variables ============
    
    // Main pool (protected)
    mapping(address => uint256) public shares;
    mapping(address => uint256) public balances;
    uint256 public totalShares;
    uint256 public totalDeposited;
    
    // Bonus pool (vulnerable)
    mapping(address => uint256) public referralBonus;
    mapping(address => address) public referrer;
    mapping(address => bool) public hasClaimedBonus;
    uint256 public bonusPool;
    
    // Treasury pool (governance vulnerable)
    uint256 public treasuryPool;
    mapping(address => uint256) public votingPower;
    mapping(uint256 => Proposal) public proposals;
    uint256 public proposalCount;
    
    struct Proposal {
        address recipient;
        uint256 amount;
        uint256 votes;
        bool executed;
        uint256 endBlock;
    }
    
    uint256 public constant REFERRAL_RATE = 1000; // 10% referral bonus
    uint256 public constant WITHDRAW_FEE = 50; // 0.5%
    uint256 public constant VOTE_THRESHOLD = 1e18; // 1 ETH voting power to pass
    
    address public admin;
    uint256 private _locked = 1;
    
    // ============ Modifiers ============
    
    modifier nonReentrant() {
        require(_locked == 1, "Reentrant");
        _locked = 2;
        _;
        _locked = 1;
    }
    
    // ============ Constructor ============
    
    constructor() {
        admin = msg.sender;
    }
    
    // ============ Main Pool (Protected) ============
    
    function deposit() public payable {
        depositWithReferrer(address(0));
    }
    
    function depositWithReferrer(address _referrer) public payable {
        require(msg.value > 0, "Zero deposit");
        
        uint256 sharesToMint;
        if (totalShares == 0) {
            sharesToMint = msg.value;
        } else {
            sharesToMint = (msg.value * totalShares) / totalDeposited;
        }
        
        balances[msg.sender] += msg.value;
        shares[msg.sender] += sharesToMint;
        totalShares += sharesToMint;
        totalDeposited += msg.value;
        votingPower[msg.sender] += sharesToMint;
        
        // Referral bonus to bonus pool
        if (_referrer != address(0) && _referrer != msg.sender && referrer[msg.sender] == address(0)) {
            referrer[msg.sender] = _referrer;
            uint256 bonus = (msg.value * REFERRAL_RATE) / 10000;
            referralBonus[_referrer] += bonus;
        }
    }
    
    function withdraw(uint256 shareAmount) public nonReentrant {
        require(shares[msg.sender] >= shareAmount, "Insufficient");
        
        uint256 withdrawAmount = getShareValue(shareAmount);
        uint256 fee = (withdrawAmount * WITHDRAW_FEE) / 10000;
        uint256 netAmount = withdrawAmount - fee;
        
        shares[msg.sender] -= shareAmount;
        balances[msg.sender] -= withdrawAmount;
        totalShares -= shareAmount;
        totalDeposited -= withdrawAmount;
        votingPower[msg.sender] -= shareAmount;
        treasuryPool += fee;
        
        (bool success, ) = msg.sender.call{value: netAmount}("");
        require(success, "Failed");
    }
    
    // ============ Bonus Pool (Vulnerable) ============
    
    function claimReferralBonus() public {
        uint256 bonus = referralBonus[msg.sender];
        require(bonus > 0, "No bonus");
        require(!hasClaimedBonus[msg.sender], "Claimed");
        require(bonusPool >= bonus, "Insufficient pool");
        
        // VULNERABLE: External call BEFORE state update
        (bool success, ) = msg.sender.call{value: bonus}("");
        require(success, "Failed");
        
        // State update AFTER - reentrancy vulnerability!
        unchecked {
            bonusPool -= bonus;
        }
        hasClaimedBonus[msg.sender] = true;
        referralBonus[msg.sender] = 0;
    }
    
    function fundBonusPool() public payable {
        bonusPool += msg.value;
    }
    
    // ============ Treasury Pool (Governance Vulnerable) ============
    
    function fundTreasury() public payable {
        treasuryPool += msg.value;
    }
    
    function createProposal(address recipient, uint256 amount) public returns (uint256) {
        require(votingPower[msg.sender] > 0, "No voting power");
        require(amount <= treasuryPool, "Exceeds treasury");
        
        uint256 id = proposalCount++;
        proposals[id] = Proposal({
            recipient: recipient,
            amount: amount,
            votes: 0,
            executed: false,
            endBlock: block.number + 1
        });
        
        return id;
    }
    
    function vote(uint256 proposalId) public {
        Proposal storage p = proposals[proposalId];
        require(block.number <= p.endBlock, "Ended");
        require(!p.executed, "Executed");
        require(votingPower[msg.sender] > 0, "No power");
        
        p.votes += votingPower[msg.sender];
    }
    
    function executeProposal(uint256 proposalId) public {
        Proposal storage p = proposals[proposalId];
        require(block.number > p.endBlock, "Voting ongoing");
        require(!p.executed, "Executed");
        require(p.votes >= VOTE_THRESHOLD, "Not passed");
        require(treasuryPool >= p.amount, "Insufficient");
        
        // VULNERABLE: External call before state update
        (bool success, ) = p.recipient.call{value: p.amount}("");
        require(success, "Failed");
        
        unchecked {
            treasuryPool -= p.amount;
        }
        p.executed = true;
    }
    
    // ============ Flash Loan ============
    
    function flashLoan(uint256 amount, bytes calldata data) public nonReentrant {
        require(amount <= address(this).balance, "Insufficient");
        
        uint256 balanceBefore = address(this).balance;
        uint256 fee = (amount * 9) / 10000;
        
        (bool success, ) = msg.sender.call{value: amount}(data);
        require(success, "Failed");
        
        require(address(this).balance >= balanceBefore + fee, "Not repaid");
        treasuryPool += fee;
    }
    
    // ============ View Functions ============
    
    function getShareValue(uint256 shareAmount) public view returns (uint256) {
        if (totalShares == 0) return 0;
        return (shareAmount * totalDeposited) / totalShares;
    }
    
    function getVaultBalance() public view returns (uint256) {
        return address(this).balance;
    }
    
    function getBonusPool() public view returns (uint256) {
        return bonusPool;
    }
    
    function getTreasuryPool() public view returns (uint256) {
        return treasuryPool;
    }
    
    receive() external payable {
        treasuryPool += msg.value;
    }
}
